<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/fonts/dank-mono.css">
    <link rel="me" href="https://mas.to/@snugug">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="generator" content="Astro v1.6.2">
    <title>Dude, Where&#39;s My Modal? | Snugug</title>
    <meta name="description" content="Modals. Popups. Overlays. Dialog Boxes. No matter what you call them; ugh. I can't even. If I were being gracious, I'd say that nine times out of ten, modals are the lazy way out of solving a hard (or sometimes not so hard) design or development problem. We should stop doing that.">
  <link rel="stylesheet" href="/assets/cookbook.40b0c718.css" />
<link rel="stylesheet" href="/assets/_slug_.baf2ea72.css" /><script type="module">"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js",{scope:"/"})});
</script></head>
  <body class="body">
    <style>astro-island,astro-slot{display:contents}</style><script>(self.Astro=self.Astro||{}).load=a=>{(async()=>await(await a())())()},window.dispatchEvent(new Event("astro:load"));var l;{const c={0:t=>t,1:t=>JSON.parse(t,o),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(JSON.parse(t,o)),5:t=>new Set(JSON.parse(t,o)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(JSON.parse(t)),9:t=>new Uint16Array(JSON.parse(t)),10:t=>new Uint32Array(JSON.parse(t))},o=(t,s)=>{if(t===""||!Array.isArray(s))return s;const[e,n]=s;return e in c?c[e](n):void 0};customElements.get("astro-island")||customElements.define("astro-island",(l=class extends HTMLElement{constructor(){super(...arguments);this.hydrate=()=>{if(!this.hydrator||this.parentElement&&this.parentElement.closest("astro-island[ssr]"))return;const s=this.querySelectorAll("astro-slot"),e={},n=this.querySelectorAll("template[data-astro-template]");for(const r of n){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(const r of s){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("name")||"default"]=r.innerHTML)}const a=this.hasAttribute("props")?JSON.parse(this.getAttribute("props"),o):{};this.hydrator(this)(this.Component,a,e,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),window.removeEventListener("astro:hydrate",this.hydrate),window.dispatchEvent(new CustomEvent("astro:hydrate"))}}connectedCallback(){!this.hasAttribute("await-children")||this.firstChild?this.childrenConnectedCallback():new MutationObserver((s,e)=>{e.disconnect(),this.childrenConnectedCallback()}).observe(this,{childList:!0})}async childrenConnectedCallback(){window.addEventListener("astro:hydrate",this.hydrate);let s=this.getAttribute("before-hydration-url");s&&await import(s),this.start()}start(){const s=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(Astro[e]===void 0){window.addEventListener(`astro:${e}`,()=>this.start(),{once:!0});return}Astro[e](async()=>{const n=this.getAttribute("renderer-url"),[a,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),i=this.getAttribute("component-export")||"default";if(!i.includes("."))this.Component=a[i];else{this.Component=a;for(const d of i.split("."))this.Component=this.Component[d]}return this.hydrator=r,this.hydrate},s,this)}attributeChangedCallback(){this.hydrator&&this.hydrate()}},l.observedAttributes=["props"],l))}</script><astro-island uid="1hbtu9" component-url="/Menu.bd5d2339.js" component-export="default" renderer-url="/client.788af3ea.js" props="{}" ssr="" client="load" opts="{&quot;name&quot;:&quot;Menu&quot;,&quot;value&quot;:true}" await-children=""><div><button class="toggle svelte-1g8b6wp" aria-expanded="false" aria-label="Open menu"></button>

  <nav class="menu svelte-1g8b6wp" aria-expanded="false"><ul class="menu--list svelte-1g8b6wp"><li><a href="/" tabindex="-1">Home</a></li>
      <li><a href="/musings" tabindex="-1">Posts</a></li>
      <li><a href="/cookbook" tabindex="-1">Cookbook</a></li>
      <li><a href="/me" tabindex="-1">About</a></li>
      <li><a href="/presentations" tabindex="-1">Presentations</a></li>
      <li><a href="/rss.xml" tabindex="-1">RSS</a></li></ul></nav>
</div></astro-island>

    <main itemscope="" itemtype="http://schema.org/Blog" class="astro-UBUQI6KS">
    <article class="article astro-UBUQI6KS">
      <header class="article--heading astro-UBUQI6KS">
        <div class="heading heading--padded astro-3D5OBTLG" style="--hue: 25;--saturation: 30;--lightness: 80;--alpha: 0.2;--size: 125;">
  <h1 class="heading--title astro-3D5OBTLG" itemprop="name">Dude, Where's My Modal?</h1>
</div>


      </header>
      <div class="article--container astro-UBUQI6KS">
        <div class="article--inner astro-UBUQI6KS">
          <p class="article--date astro-UBUQI6KS">
            
            <time datetime="2015-05-03T00:00:00.000Z" class="astro-UBUQI6KS">5/3/2015
            </time>
          </p>
          <div class="article--content type astro-UBUQI6KS"><p>Modals. Popups. Overlays. Dialog Boxes. No matter what you call them; ugh. I can’t even. If I were being gracious, <a href="https://twitter.com/Snugug/status/592716919880450050">I’d say</a> that nine times out of ten, modals are the lazy way out of solving a hard (or sometimes not so hard) design or development problem. We should stop doing that.</p>
<p>Modals have lots of technical issues with them; they usually break the universally standard browser back/forward functionality, they’re amazingly hard to make accessible and usable to keyboard users, they tend to be pretty heavy to implement, there are innumerable ways to close one and it’s never implemented consistently across different modals and usually has no hinting as to what ways will work making it a guess and check system each time, having a fixed size and position that covers the full screen makes it frustratingly difficult to make responsive with any modicum of sanity or decent user experience. But, ya know, with a robust enough (and tiny enough) JavaScript library, we can probably get over most of these issues (good luck with that, though). The real problem with modals is the human brain. Modals are an anti-pattern at the level that we are able to process information.</p>
<p>Have you ever entered a room and totally forgotten why you had gone in there in the first place? Of course you have; we all have. There’s a name for that: <strong>The Doorway Effect</strong></p>
<p><img src="/images/dude-wheres-my-modal/dude.gif" alt="Dude, Where's My Car?"></p>
<p>The Doorway Effect, more formally known as the <a href="http://www.freakonomics.com/media/Radvansky%20Krawietz%20%26%20Tamplin%202011%20%28QJEP%29%20%281%29.pdf">location-updating effect</a> describes: “the finding that when people pass through a doorway to move from one location to another, they forget more information than if they do not make such a shift.… Essentially, a shift at an event boundary introduces a need to update one’s understanding of the ongoing events, and this updating process is effortful.” In their work <a href="http://www.freakonomics.com/media/Radvansky%20Krawietz%20%26%20Tamplin%202011%20%28QJEP%29%20%281%29.pdf"><em>Walking through doorways causes forgetting: Further explorations</em></a>, Gabriel A. Radvansky, Sabine A. Krawietz, and Andrea K. Tamplin of the Department of Psychology, University of Notre Dame explored whether the Doorway Effect was dependent on how the environments are experienced. Their conclusion is that no, be it physical objects in the real world or virtual objects on a small screen, the Doorway Effect was not dependent on how the way the environments are experienced.</p>
<p>Now why is the Doorway Effect so bad? Well, results showed that people make more errors when they had moved and that their response times slowed down to probes when their conditions were shifted as compared to when they were not shifted. Their conclusion? Needing to mentally update the model of what is happening winds up compromising memory.</p>
<p>In the paper, the researchers discuss an <em>event horizon model of event cognition and memory</em>. The relevant parts to the Doorway Effect are: “(a) Events can be segmented, and different event models are created with people processing one at a time”, “(b) information in the current event that is being actively processed is foregrounded”, and “(d) there is retrieval interference for competitive retrieval”.</p>
<p>The first, event segmentation, occurs when an event boundary is encountered, such as a person moving from one room to another, and a new event model may be created and stored in memory, making the event model for the prior event decline in availability.</p>
<p>The second, the event model that is currently active in working memory is foregrounded, makes it easier to retrieve information from that event. The current event model occupies working memory, and available processing capacity is directed to it.</p>
<p>The third, retrieval interference of competitive retrieval, makes a person choose one memory trace to verify that information. When people move an object from one location to another, it is now associated with two location - the location it started in and the location it ended up in. Thus, there may be two event models that contain the target information, which compete with one another at retrieval, producing interference and making retrieval slower and more error prone.</p>
<p>Now, how does this relate to the dreaded modal? Well, let’s take the most common use case for a modal: contextual actions/task/information/etc… Modals by design take over the whole screen, stripping context from our contextual needs (which kinda defeats the purpose in and of itself), but more damning, thanks to the Doorway Effect, will cause more errors and slower response times from our users than not doing so. Modals are a harsh enough switch that they wind up creating a new event model for our users, creating an event boundary, and triggering the Doorway Effect. When we close the modal? Another event switch, a new event model for our users, a new event boundary.</p>
<p>How about the other uses for modals besides contextual information? One modal for our login, one for our lightbox, one for this, that? All may be wrapped in the same modal wrapper, but all contain different inner layouts, different inner content models, different contexts. The research in <em>Walking through doorways</em> shows that increasing the number of new areas a user enters substantially increases the number of errors users have, and each new creative use for a modal is a new area for our users.</p>
<p>Here comes the grumpy, kneejerk reaction to all of this: “Fine, then what should we use instead?” Ya know what sucks? There isn’t a single drop-in replacement for modals. They’ve become the <em>deus ex machina</em> of user experience design. In order to replace such a seemingly omni-functional tool, we need to be creative. Being creative is hard, for both designers and developers, and we can be tempted not to do the hard work needed to solve our users’ problems in the best possible way for a large number of reasons, including some that can be out of our control. But we should try.</p>
<p>The first, and most obvious thing to do, is determine if clarity of context can be improved by bringing users to another page. I find this solution is best for administrative tasks as users are entering a new mental model and the cost of event switching can be justified by this new context switch while also providing ample context for users to orient themselves. I also really like this solution for user login, especially if an entire site isn’t secured (for security reasons, never let users send their passwords over non-encrypted connections). When using a new page, ensure that the URLs (and breadcrumbs, messaging, etc…, if you have them) provide users with some contextual reminders of the action they are going to perform to help ensure they don’t loose their train of through. Consider this: in places where an entirely new context is loaded into a modal, that’s probably a good place to create a new physical page for a user to navigate to.</p>
<p>The second, and one I’ve become a really big fan of, is what I’m going to call the contextual slide open (that’s a terrible name, someone suggest a better one). I first saw this pattern used in the iOS view of <a href="https://images.google.com/?gws_rd=ssl">Google Image search</a>, and has since expanded to all versions of Google Image search. The basic idea is that, instead of a modal, make the relevant content appear in-line, on the same page, contextually connected directly to the triggering element in both UI and animation, while keeping that trigger in view, with deep links to animate-in the contextual area on load, that can be closed through an obvious close indicator, by toggling the selected item, or by simply ignoring and moving on with the page, all without covering anything else on the page. While this doesn’t resolve all of the issues we encounter with the Doorway Effect, it helps to mitigate them all in a fairly elegant way as it isn’t an entirely new area, allowing for faster recovery from the event boundary by only requiring a tweak in the current event model instead of needing to build an entirely new one and removing the possibility that information is stored across two event models.</p>
<video src="https://snugug.github.io/videos/google-images-modal-replacement.mp4" controls loop>
  <p>Download a video of the <a href="https://snugug.github.io/videos/google-images-modal-replacement.mp4">Google Image Search modal replacement</a></p>
</video>
<p>With this information in had, and a couple of new patterns to consider and grow from, we should grab our bootstraps and pull ourselves out of the modal murk. As designers and developers, we are creatives, and being creative is hard. Our answer, like always, should be to do the hard work to find the best solution for our users, not simply use the same 'ol stuff without sitting back to consider if it’s actually doing what we think it is. Modals are the prototypical example of a pattern that gets used and abused without though. We should stop doing that.</p>
</div>
        </div>
      </div>
    </article>
  </main>

    <footer class="footer svelte-14m4qym"><div class="inner svelte-14m4qym"><img src="/images/me/square.jpg" alt="Headshot of Sam" class="headshot svelte-14m4qym" loading="lazy">
    <h2 class="svelte-14m4qym">Sam <br><span class="aka">aka</span> Snugug</h2>
    <p class="svelte-14m4qym">BBQ lead, ChromeOS DevRel</p>
    <p class="svelte-14m4qym">Web, design, development, food</p></div>
</footer>

    

    <script>(self.Astro=self.Astro||{}).only=t=>{(async()=>await(await t())())()},window.dispatchEvent(new Event("astro:only"));</script><astro-island uid="Z12xwGk" component-url="/Houdini.3bbc1370.js" component-export="default" renderer-url="/client.788af3ea.js" props="{}" ssr="" client="only" opts="{&quot;name&quot;:&quot;Houdini&quot;,&quot;value&quot;:true}"></astro-island>
  </body></html>

