<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/fonts/dank-mono.css">
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="generator" content="Astro v1.6.2">
    <title>Return of the CMS | Snugug</title>
    <meta name="description" content="After rebuilding my blog on a new generation headless CMS, I've rethought whether flat Markdown files in site code is worth the complexity, especially for JAMStack sites.">
  <link rel="stylesheet" href="/assets/cookbook.40b0c718.css" />
<link rel="stylesheet" href="/assets/_slug_.baf2ea72.css" /><script type="module">"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js",{scope:"/"})});
</script></head>
  <body class="body">
    <style>astro-island,astro-slot{display:contents}</style><script>(self.Astro=self.Astro||{}).load=a=>{(async()=>await(await a())())()},window.dispatchEvent(new Event("astro:load"));var l;{const c={0:t=>t,1:t=>JSON.parse(t,o),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(JSON.parse(t,o)),5:t=>new Set(JSON.parse(t,o)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(JSON.parse(t)),9:t=>new Uint16Array(JSON.parse(t)),10:t=>new Uint32Array(JSON.parse(t))},o=(t,s)=>{if(t===""||!Array.isArray(s))return s;const[e,n]=s;return e in c?c[e](n):void 0};customElements.get("astro-island")||customElements.define("astro-island",(l=class extends HTMLElement{constructor(){super(...arguments);this.hydrate=()=>{if(!this.hydrator||this.parentElement&&this.parentElement.closest("astro-island[ssr]"))return;const s=this.querySelectorAll("astro-slot"),e={},n=this.querySelectorAll("template[data-astro-template]");for(const r of n){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(const r of s){const i=r.closest(this.tagName);!i||!i.isSameNode(this)||(e[r.getAttribute("name")||"default"]=r.innerHTML)}const a=this.hasAttribute("props")?JSON.parse(this.getAttribute("props"),o):{};this.hydrator(this)(this.Component,a,e,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),window.removeEventListener("astro:hydrate",this.hydrate),window.dispatchEvent(new CustomEvent("astro:hydrate"))}}connectedCallback(){!this.hasAttribute("await-children")||this.firstChild?this.childrenConnectedCallback():new MutationObserver((s,e)=>{e.disconnect(),this.childrenConnectedCallback()}).observe(this,{childList:!0})}async childrenConnectedCallback(){window.addEventListener("astro:hydrate",this.hydrate);let s=this.getAttribute("before-hydration-url");s&&await import(s),this.start()}start(){const s=JSON.parse(this.getAttribute("opts")),e=this.getAttribute("client");if(Astro[e]===void 0){window.addEventListener(`astro:${e}`,()=>this.start(),{once:!0});return}Astro[e](async()=>{const n=this.getAttribute("renderer-url"),[a,{default:r}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),i=this.getAttribute("component-export")||"default";if(!i.includes("."))this.Component=a[i];else{this.Component=a;for(const d of i.split("."))this.Component=this.Component[d]}return this.hydrator=r,this.hydrate},s,this)}attributeChangedCallback(){this.hydrator&&this.hydrate()}},l.observedAttributes=["props"],l))}</script><astro-island uid="1hbtu9" component-url="/Menu.bd5d2339.js" component-export="default" renderer-url="/client.788af3ea.js" props="{}" ssr="" client="load" opts="{&quot;name&quot;:&quot;Menu&quot;,&quot;value&quot;:true}" await-children=""><div><button class="toggle svelte-1g8b6wp" aria-expanded="false" aria-label="Open menu"></button>

  <nav class="menu svelte-1g8b6wp" aria-expanded="false"><ul class="menu--list svelte-1g8b6wp"><li><a href="/" tabindex="-1">Home</a></li>
      <li><a href="/musings" tabindex="-1">Posts</a></li>
      <li><a href="/cookbook" tabindex="-1">Cookbook</a></li>
      <li><a href="/me" tabindex="-1">About</a></li>
      <li><a href="/presentations" tabindex="-1">Presentations</a></li>
      <li><a href="/rss.xml" tabindex="-1">RSS</a></li></ul></nav>
</div></astro-island>

    <main itemscope="" itemtype="http://schema.org/Blog" class="astro-UBUQI6KS">
    <article class="article astro-UBUQI6KS">
      <header class="article--heading astro-UBUQI6KS">
        <div class="heading heading--padded astro-3D5OBTLG" style="--hue: 25;--saturation: 30;--lightness: 80;--alpha: 0.2;--size: 125;">
  <h1 class="heading--title astro-3D5OBTLG" itemprop="name">Return of the CMS</h1>
</div>


      </header>
      <div class="article--container astro-UBUQI6KS">
        <div class="article--inner astro-UBUQI6KS">
          <p class="article--date astro-UBUQI6KS">
            
            <time datetime="2022-11-07T00:00:00.000Z" class="astro-UBUQI6KS">11/7/2022
            </time>
          </p>
          <div class="article--content type astro-UBUQI6KS"><p>I really didn’t like writing my last blog post. It wasn’t the content. I really don’t like maintaining content as flat markdown files. It’s something I thought was great for a Avery long time, but the more I do it, both personally and professionally, the more I hate it. I got my start in content management systems and, while I would never return to a fat stack CMS like Drupal or Wordpress, I missed the simplicity of structured meta fields and a <code>textarea</code>, so I decided to make a change.</p>
<section>
<h2 id="the-tyranny-of-the-unstructured-text-box" tabindex="-1"><a class="header-anchor" href="#the-tyranny-of-the-unstructured-text-box">The tyranny of the unstructured text box</a></h2>
<p>Back when I worked at NBCUniversal, a friend of mine (also named Sam, we were &quot;backend Sam and front-end Sam, or together, the Sams) used the phrase the phrase “the tyranny of the unstructured text box” to describe how, when presented with something totally unstructured like a blank text area, the possibilities of what to do with it can become overwhelming. Because of that, we wind up creating structure to fill the void. What I’ve come to realize is there’s no more tyrannical of an unstructured text box than an empty Markdown file.</p>
<p>I love Markdown. This post is written in Markdown. I take notes in Markdown. But there may not be a greater text box tyrant than Markdown. For every project where the primary content structure is Markdown, I need to make the following <em>additional</em> decisions:</p>
<ul>
<li>What flavor of Markdown am I going to use?</li>
<li>What subset of features of that flavor am I going to allow?</li>
<li>What missing features do I need?</li>
<li>What should the syntax for those features be?</li>
<li>What renderer should I use?</li>
<li>How can I validate the content written?</li>
<li>How can I attach meta-information to my markdown (like title, publishing date, and the like)</li>
<li>How can I validate that meta-information to make sure ita structured right each time?</li>
<li>How tightly do I need to couple my codebase to my particular duct-tape and string Markdown architecture?</li>
<li>Can I use Markdown at all or do I need to use a variant, like MDX?</li>
</ul>
<p>And the list goes on. The decisions I made for ChromeOS.dev have  changed a number of times over it’s short lifespan, but the result is always a pretty fat stack for anything non-trivial. To solve some of these problems, I’ve even gone so far as to write <a href="https://github.com/chromeos/chromeos.dev/tree/main/lib/linting">JSON Schema powered linters</a> for the YAML frontmatter. Complexity upon complexity just to avoid a CMS. But even then, am I even really doing that?</p>
<p>Highly structured YAML frontmatter for meta-information. Folder based content structure. References by the grace of our build system and hopefully unique, manually-managed IDs. What I have is really an unstructured CMS whose database has been splatted across dozens of files and folders and whose rules are hidden away in opaque logic. After working this way for years, I’ll take a web form, please.</p>
</section>
<section>
<h2 id="return-of-the-cms" tabindex="-1"><a class="header-anchor" href="#return-of-the-cms">Return of the CMS</a></h2>
<p>Like I said at the top, I’ve been doing CMSes for a long time. I started my career working in Drupal (even back then 10+ years ago advocating for what are now known as headless CMSes). I took a stab at building one while at IBM we called Punchcard. I’ve even tried CMSes that live on top of flat Markdown files, like the Netlify CMS. With all this in my back pocket I’ve gotta say, the current generation of headless CMSes are <em>really</em> good.</p>
<aside class="note"><p>While individual definitions may vary, to me, a headless CMS is one that focuses on managing content but <em>not</em> on rendering the page a user sees (the “head”). It instead provides APIs for other systems to pull the content and display it.</p>
</aside><p>I’ve never like fat stack CMSes because I always found they did a bad job at rendering the final website; in my Drupal days I worked really hard to undo most of what it gave me on the front-end. With Markdown files treated as code, you’ve got the same tight coupling problem, but in reverse! You’ve got a “bodyless” CMS! The tight coupling of code to content can also lead to awkward states where to deploy a feature you need to deploy content, or vice versa.  For a few, small things this may be OK, but when looking to scale, thing get tough. In addition to all of the above things you need to look out for, you also now need to figure out:</p>
<ul>
<li>How to let others who aren’t familiar with the codebase submit content</li>
<li>How to review said content (which usually has a different set of needs than code)</li>
<li>How to stage content not ready to be published</li>
<li><em>Where</em> to stage content not ready to be published</li>
<li>How to schedule content to go live</li>
<li>How to reference other content and make sure it stays in sync</li>
</ul>
<p>And again, the list goes on, especially if working with non-developers or you need to localize the content.</p>
<p>The good news is pretty much every one of the current generation of headless CMSes does all this, and does it well. It then becomes finding what their UX and DX differences are, and choosing one. Heck, you can even be like me and keep writing in Markdown (for now, anyway) and move all of the content management bits to the CMS. Where it always should have been.</p>
<p>This blog post is a great example. I wrote this whole post on my phone, sitting in my backyard. Without a CMS, I would have needed to get a copy of my codebase, copy my blog post entry template, edit it, write, deal with Git from my phone, then either run everything on my computer later or rely on CI to make sure nothing I did broke any of my “rules”. With my CMS, I had form fields and a text box. Revisions were automatically saved and I can pick back up anywhere. I know what’s missing and what’s not. It’s great.</p>
</section>
<section>
<h2 id="the-great-decomplecting" tabindex="-1"><a class="header-anchor" href="#the-great-decomplecting">The great decomplecting</a></h2>
<p>So what has this done for my codebase? Well, I now have a separate codebase for my CMS that I need to manage, but it’s now only focused on one thing. Less net complexity for my content. I like it. I also mostly don’t need to touch it again, so that’s a one-time complexity sink.</p>
<p>For my codebase I’ve gone from dozens and dozens of files to, like, 10? A handful of components and a couple of layouts. It’s so much easier for me to grok my codebase now and see what connects where and how. Piles and piles of complexity removed. I love it. And, because my content isn’t tightly coupled to my code, I <em>also</em> mostly don’t need to touch it, either! From one tight coupled system where I need to touch everything to do anything to two loosely coupled systems that I basically don’t need to touch to make any content changes.</p>
<hr>
<p>So I’m all in on the new generation of headless CMSes. For me, they solve almost all of the problems I have with managing individual Markdown files and, ultimately, make it easier for me to both write new content and maintain my site’s codebase. If you’ve been thinking about it, especially if you’ve got a JAMStack site, you should consider the switch, too.</p>
</section>
</div>
        </div>
      </div>
    </article>
  </main>

    <footer class="footer svelte-14m4qym"><div class="inner svelte-14m4qym"><img src="/images/me/square.jpg" alt="Headshot of Sam" class="headshot svelte-14m4qym" loading="lazy">
    <h2 class="svelte-14m4qym">Sam <br><span class="aka">aka</span> Snugug</h2>
    <p class="svelte-14m4qym">BBQ lead, ChromeOS DevRel</p>
    <p class="svelte-14m4qym">Web, design, development, food</p></div>
</footer>

    

    <script>(self.Astro=self.Astro||{}).only=t=>{(async()=>await(await t())())()},window.dispatchEvent(new Event("astro:only"));</script><astro-island uid="Z12xwGk" component-url="/Houdini.3bbc1370.js" component-export="default" renderer-url="/client.788af3ea.js" props="{}" ssr="" client="only" opts="{&quot;name&quot;:&quot;Houdini&quot;,&quot;value&quot;:true}"></astro-island>
  </body></html>

